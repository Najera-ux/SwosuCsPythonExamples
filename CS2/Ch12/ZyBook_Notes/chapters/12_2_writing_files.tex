\chapter{12.2 Writing Files}

\section*{Overview}
Programs write to files to store data permanently.  
The \texttt{file.write()} method writes a string argument to a file.  
This section teaches how to open files for writing, the difference between modes,  
and why errors occur when you write the wrong data type.

\begin{quote}
\textbf{Helpful documentation:}
\begin{itemize}
  \item \href{https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files}{Python Docs: Reading and Writing Files}
  \item \href{https://docs.python.org/3/library/functions.html#open}{\texttt{open()} built-in function}
  \item \href{https://docs.python.org/3/library/io.html#io.TextIOBase.write}{\texttt{io.TextIOBase.write()}}
  \item \href{https://docs.python.org/3/library/os.html#os.fsync}{\texttt{os.fsync()}}
\end{itemize}
\end{quote}

\section{Writing to a File}

\begin{lstlisting}[language=Python, caption={Basic example: Writing text to a file.}]
def write_basic_example():
    """Write two lines to a new file."""
    with open("myfile.txt", "w", encoding="utf-8") as f:
        f.write("Example string.\n")
        f.write("test....\n")
    print("File written successfully!")

write_basic_example()
\end{lstlisting}

\noindent
\textbf{Key idea:} Opening a file in mode \texttt{"w"} creates it if missing and overwrites it if it already exists.

---

\section{Why Some Writes Fail}

\begin{lstlisting}[language=Python, caption={Example: Handling write errors gracefully.}]
def demonstrate_wrong_write():
    """Show why writing numbers directly causes a TypeError."""
    try:
        with open("wrong_write.txt", "w", encoding="utf-8") as f:
            # This will fail: write() only accepts strings.
            f.write(10.0)
    except TypeError as e:
        print("Caught error:", e)
        print("Explanation: write() in text mode needs a string, not a number.")

    # Correct way: convert numbers to strings.
    with open("right_write.txt", "w", encoding="utf-8") as f:
        num1, num2 = 5, 7.5
        total = num1 + num2
        f.write(str(num1))
        f.write(" + ")
        f.write(str(num2))
        f.write(" = ")
        f.write(str(total))
        f.write("\n")
    print("Fixed version works correctly!")

demonstrate_wrong_write()
\end{lstlisting}

---

\section{File Modes}

\begin{center}
\begin{tabular}{l l l l l}
\textbf{Mode} & \textbf{Description} & \textbf{Read?} & \textbf{Write?} & \textbf{Overwrite?} \\
\hline
\texttt{r} & Read only & Yes & No & No \\
\texttt{w} & Write (overwrite) & No & Yes & Yes \\
\texttt{a} & Append to end & No & Yes & No \\
\texttt{r+} & Read and write (must exist) & Yes & Yes & No \\
\texttt{w+} & Read and write (truncates) & Yes & Yes & Yes \\
\texttt{a+} & Read and append & Yes & Yes & No \\
\texttt{x} & Create new file (error if exists) & No & Yes & N/A \\
\end{tabular}
\end{center}

\begin{lstlisting}[language=Python, caption={Example: Trying wrong modes, then fixing.}]
from pathlib import Path
import io

def show_file(path):
    p = Path(path)
    print(f"\n[{p.name}] contents:")
    print(p.read_text(encoding="utf-8") if p.exists() else "<missing>")

def demonstrate_modes():
    path = "modes_demo.txt"
    Path(path).write_text("START\n", encoding="utf-8")

    # Wrong: open in read mode, try to write
    try:
        with open(path, "r", encoding="utf-8") as f:
            f.write("APPEND\n")
    except io.UnsupportedOperation as e:
        print("Error:", e)
        print("Explanation: 'r' is read-only; writing is not allowed.")

    # Correct: append mode
    with open(path, "a", encoding="utf-8") as f:
        f.write("APPEND\n")
    show_file(path)

demonstrate_modes()
\end{lstlisting}

---

\section{Buffered Output}

Python buffers output before writing to disk.  
This means data may not appear immediately in the file system until a newline, \texttt{flush()}, or \texttt{close()}.

\begin{lstlisting}[language=Python, caption={Example: Forcing a buffer flush.}]
import os, time
from pathlib import Path

def buffering_demo(path="buffer_demo.txt"):
    p = Path(path)
    if p.exists():
        p.unlink()

    f = open(path, "w", encoding="utf-8")
    f.write("Write me (no newline)")  # stays in memory
    print("Before flush: file may still be empty.")
    time.sleep(1)
    f.flush()          # Push data from Python to OS
    os.fsync(f.fileno())  # Ask OS to sync to disk
    f.close()
    print("After flush: file contents written.")

buffering_demo()
\end{lstlisting}

---

\section{Quiz Demonstrations}

\begin{lstlisting}[language=Python, caption={Mini-quiz code with real behavior.}]
def quiz_behavior():
    print("\n1) f.write(10.0) produces error:")
    try:
        with open("q1.txt", "w", encoding="utf-8") as f:
            f.write(10.0)
    except TypeError as e:
        print("True:", e)

    print("\n2) write() does NOT always write immediately:")
    with open("q2.txt", "w", encoding="utf-8") as f:
        f.write("hi")  # buffered
        print("Immediate read:", open("q2.txt").read())
        f.flush()
    print("After flush: data is saved.")

    print("\n3) flush()/fsync() forces output to disk:")
    import os
    with open("q3.txt", "w", encoding="utf-8") as f:
        f.write("sync me")
        f.flush()
        os.fsync(f.fileno())
    print("True: Data synced to disk.")

quiz_behavior()
\end{lstlisting}

---

\section{Safe File Creation}

\begin{lstlisting}[language=Python, caption={Use 'x' mode to avoid accidental overwrite.}]
def create_once(filename="create_once.txt"):
    try:
        with open(filename, "x", encoding="utf-8") as f:
            f.write("File created successfully.\n")
        print("Created new file:", filename)
    except FileExistsError:
        print("File already exists; not overwritten.")

create_once()
create_once()
\end{lstlisting}

---

\section*{Summary}
\begin{itemize}
  \item Mode \texttt{"w"} overwrites, \texttt{"a"} appends, \texttt{"x"} creates new.
  \item \texttt{write()} requires strings; convert numbers with \texttt{str()} or f-strings.
  \item Output may be buffered; use \texttt{flush()} or close the file.
  \item Use \texttt{with open(...)} to ensure the file closes automatically.
\end{itemize}
